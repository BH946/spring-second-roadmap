## Intro..

**실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화**

* 인프런 강의 듣고 공부한 내용입니다.
* **유용한 단축키**
  * `Alt + Insert` : getter, setter, constructor 등 자동 생성
  * `Ctrl + Alt + V` : 변수 선언부를 자동 작성
  * `Ctrl + Alt + M` : 코드 리팩토링하기 쉽게끔 함수 자동 생성
  * `Ctrl + Shift + Down/Up` : 메소드 코드 통째로 위, 아래 자리 이동 가능
  * `Alt + Shift + Down/Up` : 코드 한줄을 위, 아래 자리 이동 가능
  * `Ctrl + D` : 코드 한줄 바로 아래에 복제
  * `Ctrl + Alt + Shift` : 멀티 커서 가능
  * `Shift + F6` : 변수명을 한번에 바꿀 때 사용
  * `Alt + 1 ` : 왼쪽 프로젝트 폴더 구조 열기
  * `Alt + F12` : 터미널 창 열기


<br>

해당 프로젝트 폴더는 강의를 수강 후 강의에서 진행한 프로젝트를 직접 따라 작성했습니다.

따로 강의 자료(pdf)를 주시기 때문에 필요할때 해당 자료를 이용할 것이고,

이곳 README.md 파일에는 기억할 내용들만 간략히 정리하겠습니다.

* 자세한 코드가 궁금하다면, 올려둔 프로젝트에서 코드확인(커밋 위주로 보면 보기 편할 것)
* 정리하다 보니 좀 많이 정리하는 감이..

<br><br>

## API 개발 고급편 정리

**이번 강의에서는 OSIV와 성능 최적화 와 이것(API 개발 고급 정리) 이 핵심이다!!**    

**따라서 전체적으론 간략히 소개할 것이며, 자세한건 프로젝트에서 코드를 볼 것!!**

<br>

### 조회의 2가지 방법!!

* **엔티티 조회**
  * 엔티티를 조회 해서 그대로 반환: V1
    * 당연히 외부노출 하지 말라고 몇번이나 언급했음!! ( 이유도 이젠 생략하겠다 )
  * 엔티티를 조회 후 DTO로 변환: V2 
    * DTO로 변환해서 의존성 제거하는것도 몇번이나 언급!!( 내부까지 전부 관련된거 싹다 할 것!! )
  * 페치조인으로 쿼리 수 최적화: V3 
    * 실무에선 페이징 할일이 많기 때문에 페이징의 한계가 아쉬운 단계
    * 어디서 쓰는지 간단히 소개하자면?
      * 데이터 백만개면? 페이징 단위로 적당히 끊어서 api로 넘기거나 해야할거다.
      * 또한, 게시물 보여주는 경우 10~20개 연관 게시물을 빠르게 보여줘야하는데 이때도 페이징 단위로 빠르게 가져와야할거다.
  * 컬렉션 페이징과 한계돌파: V3.1
    * 컬렉션은 페치조인시 페이징이 불가능 
    * ToOne 관계는 페치 조인으로 쿼리 수 최적화, 페이징도 당연히 문제없음
    * 따라서 컬렉션은 페치조인 대신에 지연로딩을 유지하고, `hibernate.default_batch_fetch_size`, `@BatchSize` 로 최적화 (전역, 부분 이라는 차이점 있음)

* **DTO 직접 조회**
  * JPA에서 DTO를 직접 조회: V4
  * 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화: V5 
  * 플랫 데이터 최적화 - JOIN 결과를 그대로 조회후 애플리케이션에서 원하는 모양으로 직접 변환: V6

<br>

### 권장 순서

1.  **엔티티 조회** 방식으로 우선접근
    1.  페치조인으로 쿼리 수를 최적화
    2.  컬렉션 최적화
        1.  페이징 필요O `hibernate.default_batch_fetch_size` , `@BatchSize` 로 최적화
        2.  페이징 필요X => 페치조인사용
2.  엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
3.  DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate 활용

<br>

**이러한 권장 순서의 근거는??**

* 엔티티 조회 방식은 페치 조인이나, `hibernate.default_batch_fetch_size` , `@BatchSize` 같이 코드를 거의 수정하지 않고, 옵션만 약간 변경해서, 다양한 성능 최적화를 시도할 수있다.   
  반면에 DTO를 직접조회 하는방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할때 많은코드를 변경 해야한다
* 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야한다.   
  항상그런것은 아니지만, 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다.
* 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서, 성능을 최적화 할 수있다.  
  반면에 DTO 조회방식은 SQL을 직접 다루는것과 유사하기 때문에, 둘 사이에 줄타기를 해야한다.
  * 강사님께서 기존에는 성능 최적화를 위해서 복잡하게 코드를 작성했다고 하는데 알고보니 `@batchsize` 기능 같은것을 직접 한땀한땀 코드를 수정해서 바꾼 그런 작업이였다고한다. 
  * 이때 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해준다는것을 더 이해하게 되었다고 한다.

<br>

**엔티티 조회는 위에서 권장순서 자세히 설명을 했다. DTO 조회 방식의 선택지는??**

* DTO로 조회하는 방법도 각각 장단이 있다.   
  V4, V5, V6에서 단순하게 쿼리가 1번 실행된다고 V6이 항상 좋은방법인 것은 아니다.
* V4는 코드가단순하다. 특정 주문 한건만 조회하면 이 방식을 사용해도 성능이 잘 나온다.   
  * 예를들어서 조회한 Order 데이터가 1건이면 OrderItem을 찾기 위한 쿼리도 1번만 실행하면 된다.
* V5는 코드가 복잡하다. 여러주문을 한꺼번에 조회하는 경우에는 V4 대신에 이것을 최적화한 V5 방식을 사용해야 한다.   
  * 예를들어서 조회한 Order 데이터가 1000건인데, V4 방식을 그대로 사용하면, 쿼리가 총 1 + 1000번 실행된다. 여기서 1은 Order 를 조회한 쿼리고, 1000은 조회된 Order의 row 수다.   
    V5 방식으로 최적화하면 쿼리가 총 1 + 1번만실행된다. 상황에 따라 다르겠지만 운영환경에서 100배 이상의성능 차이가 날수있다.
* V6는 완전히 다른 접근방식이다.   
  쿼리 한번으로 최적화 되어서 상당히 좋아보이지만, Order를 기준으로 페이징이 불가능하다. 
  * 실무에서는 이정도 데이터면 수백이나, 수천건 단위로 페이징 처리가 꼭 필요하므로, 이경우 선택하기 어려운 방법이다.  
    그리고 데이터가 많으면 중복 전송이 증가해서 V5와 비교해서 성능 차이도미비하다.

<br>

### 페이징 불가능? 1+N? 컬렉션 최적화?

**어떤 문제들인지 하나하나 설명하겠다.**

* **페이징 불가능?**
  * order와 orderitem이 있고, orderitem이 데이터가 더 많다고 가정하자.
  * 이것을 join할 때 orderitem이 데이터가 더 많기 때문에 이것을 기준으로 order데이터가 추가로 복제된다.
  * 이때 order를 기준으로 페이징을 하면?? 불가능하다. order는 추가로 복제되었기 때문이다.
    * 당연히 orderitem을 기준으로 페이징 하는건 문제없다. 다만, 이 형태로 페이징은 매우 비추천한다.
* **1+N?**
  * order와 member, delivery가 있고, order 쿼리를 보냈는데 order 데이터가 4개(=N)를 결과로 받는다고 가정하자. + 전부 지연로딩으로 가정( 즉시로딩은 당연히 한번에 다 가져오니까 )
    * member, delivery는 지연로딩으로 인해 각각 4번씩 쿼리문을 날리게 된다.
    * 이 경우엔 1+4+4번 쿼리문이 날라가는 것이다.
    * 이를 페치조인으로 해결하는 것이다! => 쿼리 1번으로 조회 끝!!
    * 다만, ToOne 관계일때 가능하며 ToMany 관계는 좀 더 처리해야한다.
  * order와 orderitem이 있고, order 쿼리를 보냈는데 order 데이터가 2개를 결과로 받는다고 가정하자. + 전부 지연로딩 + 페치조인까지 했다고 가정.
    * 여기서 ToOne 관계였으면 문제없이 끝난다. 하지만, order는 orderitem와 ToMany 관계이다.
    * 여기서 부턴 컬렉션 최적화의 문제이다.
* **컬렉션 최적화?**
  * 일반적으로 join할 때 두 테이블의 데이터가 다르면, 작은 테이블은 추가로 복제가 된다.
  * 이때 ToMany 관계를 페치 조인을 하면 `distinct` 옵션으로 중복 제거를 한다. 
    * 이를 컬렉션 페치조인 이라고 한다. 컬렉션이기도 하면서 `distinct` 옵션을 적용하는 특징이다.
    * 다만, 컬렉션 페치조인은 1개만 사용할 수 있다.
      * 2개만 사용해도 일대다대다 관계가 되버리는데 데이터가 부정합하게 조회될 수 있다.
    * 또한, 페이징이 불가능하다.
      * 페치조인에 `distinct` 를 쓴다고 해서 DB에서 중복이 완벽히 제거가 되는게 아니라  
        앱단에서 다시 중복검사를 통해서 중복이 완벽히 제거가 되는것이기 때문에 페이징이 불가능하다.
      * 즉, DB에는 join으로 인해 다(=Many)의 개수만큼 데이터 생성되기 때문에 일(=One) 이 그만큼 다(=Many) 만큼 복제가 되어서 전체 데이터의 순서가 뒤틀리게 된다.
  * 컬렉션 최적화를 하면서 페이징도 가능하게 하고싶다면??
    * 컬렉션 페치조인을 사용하지 않고, 지연로딩을 사용해서 하이버네이트 옵션을 활용하라!!
      * `hibernate.default_batch_fetch_size , @BatchSize` : 각각 전역, 지역 size 설정이다.
      * 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다.

<br><br>

## OSIV와 성능 최적화

이거랑 아래 전체 흐름 정리하면 된다..







<br><br>

양방향 해결 & 프록시 문제(LAZY 문제) 해결 한 상태에서 LAZY 강제 초기화만 안한 상태.  
첨고로 양방향 관계 문제 발생 -> @JsonIgnore => Order과 연관된 Delivery, OrderItem, Member 에 적용했음

<img src=".\images\image-20230304223646092.png" alt="image-20230304223646092"  /> 



엔티티의 실제값 구하게 해서 DB 접근으로 LAZY 강제 초기화 한 상태  
orderitems는 XXXXXXXX => 이부분은 v3에서 다루며, 패치 조인 필요

<img src="C:\Users\KoBongHun\Desktop\Git\Study\Spring_Study\images\README\image-20230304224539759.png" alt="image-20230304224539759"  /> 



V2는 V1내용들 단순히 DTO로 변환 ( 물론 V1, V2 둘다 1+N 문제 있음 )  
당연히 엔티티보호 및 원하는 내용들로 반환해쥬는 효과



V4 는 JPA방식으로 다른조회방식인데, 파일들도 따로 부뉴했댱 레퍼지토리를 새로 만들었윰.  
물론 api 호출은 컨트롤러에 그대로 v4 버전으로 만ㄷ



뒤부터... 앞의예제에서는 toOne(OneToOne, ManyToOne) 관계만 있었다. 이번에는컬렉션인일대다관계 
(OneToMany)를조회하고, 최적화하는 방법을 알아보자.

엔티티 노출 방법 V1~..~!~!~!~!!~!~!~!

JPA에서 DTO로 바로 조회 V4~...~!~!~!~!~!



최적화 권장

니마ㅓ리ㅏ너로ㅑ더파ㅣ;ㅏㅓㅜㅠㅗㅓㅏㄷ래패아 ㅟ



OSLI>?? 이후 정리해야함.ㅎ늘.,느.



```
List<OrderItem> orderItems = order.getOrderItems();
orderItems.stream().forEach(o -> o.getItem().getName()); // Lazy 강제 초기화
```

처럼 하는거랑, 또 다른 방식 stream이거 하는거 둘다 정리.

```
.collect(Collectors.toList());

.getResultList(); => 쿼리문에 보면 있윰
```

